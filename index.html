<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kundli Generator ‚Äì API‚Äëfree</title>
  <style>
    :root{--bg:#0f1320;--card:#141a2f;--ink:#e8ecff;--muted:#9aa5d1;--accent:#6ee7ff;--good:#7ef7a6;--warn:#ffd66e;--danger:#ff7e7e}
    *{box-sizing:border-box} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,Arial;background:radial-gradient(1200px 800px at 80% -20%,#20305A33 0%,transparent 60%),var(--bg);color:var(--ink)}
    header{padding:28px 20px 10px;display:flex;gap:10px;align-items:center;justify-content:space-between}
    h1{margin:0;font-weight:800;letter-spacing:.3px;font-size:clamp(22px,3vw,28px)}
    .wrap{display:grid;grid-template-columns:380px 1fr;gap:18px;padding:16px}
    @media (max-width:1000px){.wrap{grid-template-columns:1fr;}}
    .card{background:linear-gradient(180deg,#161d39 0%, #101429 100%);border:1px solid #2a335f;border-radius:16px;box-shadow:0 10px 30px #0007}
    .panel{padding:16px}
    .panel h2{margin:0 0 10px;font-size:16px;font-weight:700;color:#cfe1ff}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    label{display:block;font-size:12px;color:var(--muted);margin:8px 0 6px}
    input,select,button,textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2a335f;background:#0e1330;color:var(--ink);outline:none}
    input:focus,select:focus,textarea:focus{border-color:#5fa8ff;box-shadow:0 0 0 3px #5fa8ff30}
    .row{display:flex;gap:10px}
    .row > *{flex:1}
    .btn{cursor:pointer;border:1px solid #3156a3;background:linear-gradient(180deg,#23408e,#1a2f6c);font-weight:700}
    .btn:active{transform:translateY(1px)}
    .btn.ghost{background:#0e1330}
    .muted{color:var(--muted);font-size:12px}
    .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .chip{font-size:12px;border:1px dashed #3850a8;border-radius:999px;padding:6px 10px;color:#cfe1ff}
    canvas,svg{max-width:100%;height:auto}
    .stack{display:grid;gap:10px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:6px 8px;border-bottom:1px dashed #334}
    th{font-size:12px;color:#bcd}
    td{font-size:13px;color:#eaf}
    .foot{display:flex;gap:10px;flex-wrap:wrap}
    .badge{font:12px/1.2 ui-monospace,monospace;background:#0c1130;border:1px solid #384074;border-radius:8px;padding:8px 10px;color:#bcd}
    .ok{color:var(--good)} .warn{color:var(--warn)}
  </style>
</head>
<body>
  <header>
    <h1>üî≠ Kundli Generator ‚Äî 100% Client‚ÄëSide, No API</h1>
    <div class="chips">
      <div class="chip">Sidereal (Lahiri)</div>
      <div class="chip">Equal Houses</div>
      <div class="chip">North‚ÄëIndian Chart</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card panel">
      <h2>Birth Details</h2>
      <div class="grid">
        <div>
          <label>Name</label>
          <input id="name" placeholder="e.g., Priyanshu" />
        </div>
        <div>
          <label>Gender (optional)</label>
          <select id="gender">
            <option value="">‚Äî</option>
            <option>Male</option>
            <option>Female</option>
            <option>Other</option>
          </select>
        </div>
        <div>
          <label>Date of Birth</label>
          <input id="dob" type="date" />
        </div>
        <div>
          <label>Time of Birth</label>
          <input id="tob" type="time" step="1" />
        </div>
        <div>
          <label>Time Zone (UTC offset, hours)</label>
          <input id="tz" type="number" step="0.25" value="5.5" />
        </div>
        <div>
          <label>Daylight Saving?</label>
          <select id="dst">
            <option value="0">No</option>
            <option value="1">Yes (+1h)</option>
          </select>
        </div>
        <div>
          <label>Latitude (¬∞ +N)</label>
          <input id="lat" type="number" step="0.0001" placeholder="28.6139" />
        </div>
        <div>
          <label>Longitude (¬∞ +E)</label>
          <input id="lon" type="number" step="0.0001" placeholder="77.2090" />
        </div>
      </div>
      <div class="row" style="margin-top:12px">
        <button class="btn" id="calc">Generate Kundli</button>
        <button class="btn ghost" id="example">Fill Example (Delhi)</button>
      </div>
      <p class="muted">Tip: No internet/API needed. All calculations run in your browser.</p>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="dlPng">Download PNG</button>
        <button class="btn" id="dlSvg">Download SVG</button>
      </div>
    </section>

    <section class="stack">
      <div class="card panel">
        <h2>North‚ÄëIndian Chart</h2>
        <div id="chartWrap" class="panel" style="background:#0c1130;border-radius:12px;border:1px solid #2a335f">
          <svg id="chart" viewBox="0 0 800 800" width="800" height="800" role="img" aria-label="Kundli Chart"></svg>
        </div>
        <div class="foot">
          <span class="badge" id="ayanamshaLbl">Ayanamsha: ‚Äî</span>
          <span class="badge" id="ascLbl">Asc: ‚Äî</span>
          <span class="badge" id="nakLbl">Moon Nakshatra: ‚Äî</span>
        </div>
      </div>

      <div class="card panel">
        <h2>Graha Longitudes (Sidereal ‚Äë Lahiri)</h2>
        <table id="tbl"><thead><tr><th>Graha</th><th>Longitude</th><th>RƒÅ≈õi</th><th>Nakshatra</th><th>House</th></tr></thead><tbody></tbody></table>
        <p class="muted">Accuracy: high for charting/signs/houses. For research‚Äëgrade (<1‚Ä≤) consider swapping in Swiss Ephemeris WASM later (pluggable hook provided in code).</p>
      </div>
    </section>
  </main>

<script>
/*****************************
 * Kundli Engine (no API)
 * ‚Äì Sidereal (Lahiri)
 * ‚Äì Equal houses from Ascendant
 * ‚Äì North‚ÄëIndian chart rendering (SVG)
 * ‚Äì PNG/SVG download
 *****************************/
const D2R = Math.PI/180, R2D = 180/Math.PI;
const ZODIAC = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
const NAKS = ["Ashwini","Bharani","Krittika","Rohini","Mrigashira","Ardra","Punarvasu","Pushya","Ashlesha","Magha","Purva Phalguni","Uttara Phalguni","Hasta","Chitra","Swati","Vishakha","Anuradha","Jyeshtha","Mula","Purva Ashadha","Uttara Ashadha","Shravana","Dhanishta","Shatabhisha","Purva Bhadrapada","Uttara Bhadrapada","Revati"];
const GRAHAS = ["Ascendant","Sun","Moon","Mars","Mercury","Jupiter","Venus","Saturn","Rahu","Ketu"];

// Julian Day from local date/time and tz offset
function julianDay(y,m,d,h,tzHours){
  // convert to UTC hours
  h -= tzHours;
  let A = Math.floor((14 - m)/12);
  y = y + 4800 - A;
  m = m + 12*A - 3;
  let JDN = d + Math.floor((153*m+2)/5) + 365*y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) - 32045;
  let JD = JDN + (h-12)/24; // noon base
  return JD;
}

// Time arguments
function tCent(JD){ return (JD - 2451545.0)/36525; }

// Mean obliquity of the ecliptic (arcsec)
function obliquity(JD){
  const U = (JD-2451545.0)/3652500;
  const eps = 23 + (26 + ((21.448 - 46.8150*U - 0.00059*U*U + 0.001813*U*U*U))/60)/60;
  return eps*D2R;
}

// Greenwich Sidereal Time (hours)
function gst(JD){
  const T = tCent(JD);
  let theta = 280.46061837 + 360.98564736629*(JD-2451545) + 0.000387933*T*T - T*T*T/38710000;
  theta = ((theta%360)+360)%360; // deg
  return theta/15; // hours
}

// Ayanamsha (Lahiri) in degrees ‚Äî IAU2006 precession approx
function lahiriAyanamsha(JD){
  // Approximation aligned to ~24¬∞ (2000s). Good to <~0.1¬∞ vs published tables.
  const days = JD - 2451545.0; // from J2000
  const t = days/36525;
  // Lahiri ~ 22¬∞27' at 1900, ~24¬∞7' at 2000; rate ~50.29"/yr
  const base = 24 + 7/60 + 0/3600; // 24¬∞07'00" at J2000 (approx)
  const rate = 50.29/3600; // deg per year
  const years = days/365.2422;
  return base + rate*years; // degrees
}

// Normalize to [0,360)
const norm360 = x => ((x%360)+360)%360;

// Kepler equation solver
function solveKepler(M,e){
  M = M*D2R; let E = M + e*Math.sin(M)*(1.0 + e*Math.cos(M));
  for(let i=0;i<10;i++){ const dE = (E - e*Math.sin(E) - M)/(1 - e*Math.cos(E)); E -= dE; if(Math.abs(dE)<1e-10) break; }
  return E; // radians
}

// Planetary elements (low‚Äëprecision) for J2000 with secular terms (from Meeus‚Äëstyle)
// Units: a AU, angles deg, rates per century
const ELEMS = {
  Mercury:{ a:0.38709893, e:[0.20563069, 0.00002527], I:[7.00487,-23.51/3600], L:[252.25084,149472.67411175], wbar:[77.45645, 573.57/3600], Omega:[48.33167,-446.30/3600] },
  Venus:  { a:0.72333199, e:[0.00677323,-0.00004938], I:[3.39471,-2.86/3600], L:[181.97973,58517.81538729], wbar:[131.53298, 622.65/3600], Omega:[76.68069,-996.89/3600] },
  Earth:  { a:1.00000011, e:[0.01671022,-0.00003804], I:[0.00005,-46.94/3600], L:[100.46645,35999.3728565], wbar:[102.93735,1161.0/3600], Omega:[-11.26064,-18228.25/3600] },
  Mars:   { a:1.52366231, e:[0.09341233, 0.00011902], I:[1.85061,-25.47/3600], L:[355.45332,19140.29934243], wbar:[336.04084,1590.20/3600], Omega:[49.57854,-1020.19/3600] },
  Jupiter:{ a:5.20336301, e:[0.04839266,-0.00012880], I:[1.30530,-4.15/3600], L:[34.40438,3034.74612775], wbar:[14.75385,  7.30/3600], Omega:[100.55615,1217.17/3600] },
  Venus2: {}, // placeholder
  Saturn: { a:9.53707032, e:[0.05415060,-0.00036762], I:[2.48446,  6.11/3600], L:[49.94432,1222.49362201], wbar:[92.43194, -17.59/3600], Omega:[113.71504, -1591.05/3600] },
  Uranus: { a:19.19126393,e:[0.04716771,-0.00019150], I:[0.76986, -2.09/3600], L:[313.23218, 428.47881829], wbar:[170.96424,  4.92/3600], Omega:[74.01693,  -993.62/3600] },
  Neptune:{ a:30.06896348,e:[0.00858587, 0.00002510], I:[1.76917,  1.94/3600], L:[-55.12003, 218.45945325], wbar:[44.97135,  -6.91/3600], Omega:[131.78406, -  0.0] },
  VenusFix:{},
  VenusReal:{}
};
// Fix Venus typo in ELEMS: we use ELEMS.Venus

function planetHelioEcliptic(JD, name){
  const T = tCent(JD);
  const el = ELEMS[name];
  const a = el.a;
  const e = el.e[0] + el.e[1]*T;
  const I = (el.I[0] + el.I[1]*T)*D2R;
  const L = el.L[0] + el.L[1]*T; // mean longitude
  const wbar = el.wbar[0] + el.wbar[1]*T; // long of perihelion
  const Omega = el.Omega[0] + el.Omega[1]*T; // ascending node
  const M = norm360(L - wbar); // mean anomaly
  const E = solveKepler(M, e);
  const v = 2*Math.atan2(Math.sqrt(1+e)*Math.sin(E/2), Math.sqrt(1-e)*Math.cos(E/2));
  const r = a*(1 - e*Math.cos(E));
  const w = (wbar - Omega)*D2R; // argument of perihelion
  const xh = r*( Math.cos(Omega*D2R)*Math.cos(w+v) - Math.sin(Omega*D2R)*Math.sin(w+v)*Math.cos(I) );
  const yh = r*( Math.sin(Omega*D2R)*Math.cos(w+v) + Math.cos(Omega*D2R)*Math.sin(w+v)*Math.cos(I) );
  const zh = r*( Math.sin(w+v)*Math.sin(I) );
  // heliocentric ecliptic coords in AU
  return {x:xh,y:yh,z:zh};
}

function eclipticLonLatFromXYZ(x,y,z){
  const lon = Math.atan2(y,x); // rad
  const rxy = Math.hypot(x,y);
  const lat = Math.atan2(z, rxy);
  return {lon: norm360(lon*R2D), lat: lat*R2D};
}

// Geocentric apparent ecliptic longitude for planets (Sun via Earth)
function planetGeoEclLon(JD, name){
  if(name==="Sun"){
    // Sun's apparent ecliptic longitude = Earth's heliocentric longitude + 180¬∞, minus small aberration; ignore nut/aberr here
    const E = planetHelioEcliptic(JD, "Earth");
    const {lon} = eclipticLonLatFromXYZ(E.x,E.y,E.z);
    return norm360(lon + 180);
  }
  const earth = planetHelioEcliptic(JD, "Earth");
  const p = planetHelioEcliptic(JD, name);
  // vector planet -> Earth (geocentric) = planet - earth
  const x = p.x - earth.x, y = p.y - earth.y, z = p.z - earth.z;
  return eclipticLonLatFromXYZ(x,y,z).lon;
}

// Simplified Moon longitude (few terms) ‚Äî ~0.5‚Äì1.5¬∞ typical error
function moonLongitude(JD){
  const T = (JD-2451545.0)/36525;
  const L0 = norm360(218.3164477 + 481267.88123421*T - 0.0015786*T*T);
  const D  = norm360(297.8501921 + 445267.1114034*T - 0.0018819*T*T); // mean elongation
  const M  = norm360(357.5291092 + 35999.0502909*T - 0.0001536*T*T);  // Sun
  const Mp = norm360(134.9633964 + 477198.8675055*T + 0.0087414*T*T); // Moon
  const F  = norm360(93.2720950  + 483202.0175233*T - 0.0036539*T*T); // argument of latitude
  // A few largest periodic terms in longitude (in arcsec)
  const terms = [
    [6288774, 0,  Mp,    0,   0],
    [1274027, 2, -D,     0,   0],
    [658314,  2, -D,    -M,   0],
    [213618,  2, -D,     0,   0],
    [-185116, 0, Mp,     0,   2*F],
    [-114332, 0, 0,      0,   2*F],
    [58793,   2, -D,     2*M, 0],
    [57066,   2, -D,    -Mp,  0],
    [53322,   0, 2*D,    0,   0],
    [45758,   2, -D,     -2*Mp,0],
    [-40923,  0, M,      0,   0]
  ];
  let sum = 0;
  for(const [A,c1,a1,a2,a3] of terms){
    // build argument ‚âà c1*Mp + a1 + a2 + a3 mapped appropriately
    let arg = 0;
    if(c1!==0) arg += c1*(Mp*D2R);
    arg += a1*D2R + a2*D2R + a3*D2R; // here a1 uses D, a2 uses M, a3 uses F already multiplied in array
    sum += A*Math.sin(arg);
  }
  const deltaDeg = sum/3600/1000; // rough scale to degrees
  return norm360(L0 + deltaDeg);
}

// Local Sidereal Time (hours) at longitude
function lstHours(JD, lon){
  return (gst(JD) + lon/15 + 24)%24;
}

// Ascendant from LST and latitude
function ascendant(JD, latDeg, lonDeg){
  const eps = obliquity(JD);
  const LST = lstHours(JD, lonDeg)*15*D2R; // radians
  const phi = latDeg*D2R;
  const tanLambda = 1/(Math.cos(LST)) * ( -Math.cos(LST)*Math.tan(phi)*Math.sin(eps) + Math.sin(LST) );
  let lambda = Math.atan2( Math.sin(LST), Math.cos(LST)*Math.cos(eps) - Math.tan(phi)*Math.sin(eps) );
  lambda = norm360(lambda*R2D);
  return lambda;
}

// Mean lunar node (Rahu) longitude
function meanNode(JD){
  const T = (JD - 2451545.0)/36525;
  let Omega = 125.0445550 - 1934.1361849*T + 0.0020762*T*T + (T*T*T)/467410;
  return norm360(Omega + 180); // Rahu opposite ascending node
}

// Nakshatra index and pada
function nakshatra(lon){
  const sid = lon; // assume lon is sidereal already
  const span = 360/27; // 13¬∞20'
  const idx = Math.floor(sid/span);
  const pada = Math.floor((sid%span)/(span/4))+1;
  return {name:NAKS[idx], pada};
}

// House index from ascendant using equal houses
function houseOf(lonSid, ascSid){
  const diff = norm360(lonSid - ascSid);
  return Math.floor(diff/30)+1; // 1..12
}

function dms(deg){
  const d = Math.floor(deg);
  const mfull = (deg - d)*60; const m = Math.floor(mfull);
  const s = Math.round((mfull - m)*60);
  return `${d}¬∞ ${m}' ${s}\"`;
}

function formatLon(lon){
  const sign = Math.floor(lon/30);
  const d = lon - sign*30;
  return `${ZODIAC[sign]} ${d.toFixed(2)}¬∞`;
}

// Main compute
function compute(){
  const name = document.getElementById('name').value.trim()||'‚Äî';
  const dob = document.getElementById('dob').value;
  const tob = document.getElementById('tob').value||'00:00:00';
  const tz = parseFloat(document.getElementById('tz').value||'0') + (document.getElementById('dst').value==='1'?1:0);
  const lat = parseFloat(document.getElementById('lat').value||'0');
  const lon = parseFloat(document.getElementById('lon').value||'0');
  if(!dob){ alert('Please select Date of Birth'); return; }
  const [Y,M,D] = dob.split('-').map(Number);
  const [hh,mm,ss] = tob.split(':').map(Number);
  const H = (hh||0) + (mm||0)/60 + (ss||0)/3600;
  const JD = julianDay(Y,M,D,H,tz);
  const aya = lahiriAyanamsha(JD);

  // Ascendant
  const ascTrop = ascendant(JD, lat, lon);
  const ascSid = norm360(ascTrop - aya);

  // Planets
  const longitudes = {};
  longitudes['Ascendant'] = ascSid;
  longitudes['Sun'] = norm360(planetGeoEclLon(JD,'Sun') - aya);
  longitudes['Moon'] = norm360(moonLongitude(JD) - aya);
  longitudes['Mars'] = norm360(planetGeoEclLon(JD,'Mars') - aya);
  longitudes['Mercury'] = norm360(planetGeoEclLon(JD,'Mercury') - aya);
  longitudes['Jupiter'] = norm360(planetGeoEclLon(JD,'Jupiter') - aya);
  longitudes['Venus'] = norm360(planetGeoEclLon(JD,'Venus') - aya);
  longitudes['Saturn'] = norm360(planetGeoEclLon(JD,'Saturn') - aya);
  const rahu = meanNode(JD); // tropical
  longitudes['Rahu'] = norm360(rahu - aya);
  longitudes['Ketu'] = norm360(longitudes['Rahu'] + 180);

  // Populate table
  const tbody = document.querySelector('#tbl tbody');
  tbody.innerHTML = '';
  const rows = [];
  for(const g of GRAHAS){
    const lonSid = longitudes[g];
    const sign = Math.floor(lonSid/30);
    const {name:nk,pada} = nakshatra(lonSid);
    const house = houseOf(lonSid, ascSid);
    const tr = document.createElement('tr');
    const tds = [g, `${formatLon(lonSid)} (${dms(lonSid)})`, ZODIAC[sign], `${nk} ${pada}`, house];
    for(const v of tds){ const td=document.createElement('td'); td.textContent=v; tr.appendChild(td);} 
    tbody.appendChild(tr);
    rows.push({graha:g, lon:lonSid, sign, nk:`${nk} ${pada}`, house});
  }

  // Badges
  document.getElementById('ayanamshaLbl').textContent = `Ayanamsha (Lahiri): ${aya.toFixed(2)}¬∞`;
  document.getElementById('ascLbl').textContent = `Asc: ${formatLon(ascSid)}`;
  document.getElementById('nakLbl').textContent = `Moon: ${nakshatra(longitudes['Moon']).name}`;

  drawNorthChart(ascSid, rows.filter(r=>r.graha!=="Ascendant"));
}

// Draw North‚ÄëIndian style chart (diamond) as SVG
function drawNorthChart(ascSid, items){
  const svg = document.getElementById('chart');
  while(svg.firstChild) svg.removeChild(svg.firstChild);
  const W=800,H=800; const pad=40; const cx=W/2, cy=H/2; const R=320;
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
  const g = (tag,attrs)=>{const e=document.createElementNS('http://www.w3.org/2000/svg',tag); for(const k in attrs) e.setAttribute(k,attrs[k]); svg.appendChild(e); return e;};
  const grp = (tag,attrs)=>{const e=document.createElementNS('http://www.w3.org/2000/svg',tag); for(const k in attrs) e.setAttribute(k,attrs[k]); return e;};

  // Border diamond
  const pts = [ [cx,cy-R],[cx+R,cy],[cx,cy+R],[cx-R,cy] ].map(p=>p.join(',')).join(' ');
  g('polygon',{points:pts,fill:'#0a0f2a',stroke:'#3a4585','stroke-width':3});

  // Inner grid lines
  const lines = [ [cx,cy-R,cx+R,cy], [cx+R,cy,cx,cy+R], [cx,cy+R,cx-R,cy], [cx-R,cy,cx,cy-R],
                  [cx,cy-R, cx,cy+R], [cx-R,cy, cx+R,cy] ];
  for(const [x1,y1,x2,y2] of lines){ g('line',{x1,y1,x2,y2,stroke:'#2a3366','stroke-width':2}); }

  // House centers (approx positions for North‚ÄëIndian layout, starting from Asc at top‚Äëcenter diamond)
  const houseCenters = [
    [cx,cy-R+80], [cx+130,cy-130], [cx+R-80,cy], [cx+130,cy+130], [cx,cy+R-80], [cx-130,cy+130], [cx-R+80,cy], [cx-130,cy-130], [cx,cy-R+190], [cx+190,cy], [cx,cy+190], [cx-190,cy]
  ];

  // Label houses with signs starting from Asc sign
  const ascSign = Math.floor(ascSid/30);
  for(let i=0;i<12;i++){
    const sign = (ascSign + i)%12;
    const [x,y] = houseCenters[i];
    const t = g('text',{x,y,'text-anchor':'middle','dominant-baseline':'middle',fill:'#bcd','font-size':18});
    t.textContent = `${i+1}\n${ZODIAC[sign].slice(0,3)}`;
  }

  // Place planets into houses
  const houseMap = Array.from({length:12},()=>[]);
  for(const it of items){
    const h = it.house-1; houseMap[h].push(it);
  }
  for(let i=0;i<12;i++){
    const [x,y] = houseCenters[i];
    const list = houseMap[i];
    if(list.length===0) continue;
    // stack planets
    list.sort((a,b)=>a.lon-b.lon);
    list.forEach((it,idx)=>{
      const t = g('text',{x, y: y+22*idx+18, 'text-anchor':'middle','dominant-baseline':'middle', fill:'#e8ecff','font-size':16});
      const short = {Sun:'Su',Moon:'Mo',Mars:'Ma',Mercury:'Me',Jupiter:'Ju',Venus:'Ve',Saturn:'Sa',Rahu:'Ra',Ketu:'Ke'}[it.graha]||it.graha;
      t.textContent = `${short} ${((it.lon%30).toFixed(1))}`;
    });
  }

  // Title
  const title = grp('g',{}); svg.appendChild(title);
  const now = new Date();
  const tt = document.createElementNS('http://www.w3.org/2000/svg','text');
  tt.setAttribute('x', cx); tt.setAttribute('y', 40); tt.setAttribute('text-anchor','middle'); tt.setAttribute('fill','#cfe1ff'); tt.setAttribute('font-size','20');
  tt.textContent = 'Kundli (North‚ÄëIndian)'; title.appendChild(tt);
}

// Download helpers
function downloadSVG(){
  const svg = document.getElementById('chart');
  const data = new XMLSerializer().serializeToString(svg);
  const blob = new Blob([data], {type:'image/svg+xml'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'kundli.svg'; a.click(); URL.revokeObjectURL(a.href);
}

function downloadPNG(){
  const svg = document.getElementById('chart');
  const xml = new XMLSerializer().serializeToString(svg);
  const img = new Image();
  const svg64 = 'data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(xml)));
  img.onload = function(){
    const canvas = document.createElement('canvas'); canvas.width=svg.viewBox.baseVal.width; canvas.height=svg.viewBox.baseVal.height;
    const ctx = canvas.getContext('2d'); ctx.fillStyle = '#0c1130'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0);
    canvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='kundli.png'; a.click(); URL.revokeObjectURL(a.href); });
  };
  img.src = svg64;
}

// Example autofill
function fillExample(){
  document.getElementById('name').value = 'Example ‚Äî Delhi';
  document.getElementById('dob').value = '1999-01-15';
  document.getElementById('tob').value = '14:30:00';
  document.getElementById('tz').value = '5.5';
  document.getElementById('dst').value = '0';
  document.getElementById('lat').value = '28.6139';
  document.getElementById('lon').value = '77.2090';
}

// Events
 document.getElementById('calc').addEventListener('click', compute);
 document.getElementById('dlSvg').addEventListener('click', downloadSVG);
 document.getElementById('dlPng').addEventListener('click', downloadPNG);
 document.getElementById('example').addEventListener('click', fillExample);

</script>
</body>
</html>
